<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="HIR (previously known as descriptors) provides a high-level object oriented access to Rust code."><title>hir - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../static.files/ayu-be46fdc453a55015.css"><script src="../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../hir/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../hir/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate hir</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">hir</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/hir/lib.rs.html#1-4349">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>HIR (previously known as descriptors) provides a high-level object oriented
access to Rust code.</p>
<p>The principal difference between HIR and syntax trees is that HIR is bound
to a particular crate instance. That is, it has cfg flags and features
applied. So, the relation between syntax and HIR is many-to-one.</p>
<p>HIR is the public API of the all of the compiler logic above syntax trees.
It is written in “OO” style. Each type is self contained (as in, it knows it’s
parents and full context). It should be “clean code”.</p>
<p><code>hir_*</code> crates are the implementation of the compiler logic.
They are written in “ECS” style, with relatively little abstractions.
Many types are not self-contained, and explicitly use local indexes, arenas, etc.</p>
<p><code>hir</code> is what insulates the “we don’t know how to actually write an incremental compiler”
from the ide with completions, hovers, etc. It is a (soft, internal) boundary:
<a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">https://www.tedinski.com/2018/02/06/system-boundaries.html</a>.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.AnyDiagnostic"><code>pub use crate::diagnostics::<a class="enum" href="diagnostics/enum.AnyDiagnostic.html" title="enum hir::diagnostics::AnyDiagnostic">AnyDiagnostic</a>;</code></div></li><li><div class="item-name" id="reexport.BreakOutsideOfLoop"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.BreakOutsideOfLoop.html" title="struct hir::diagnostics::BreakOutsideOfLoop">BreakOutsideOfLoop</a>;</code></div></li><li><div class="item-name" id="reexport.ExpectedFunction"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.ExpectedFunction.html" title="struct hir::diagnostics::ExpectedFunction">ExpectedFunction</a>;</code></div></li><li><div class="item-name" id="reexport.InactiveCode"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.InactiveCode.html" title="struct hir::diagnostics::InactiveCode">InactiveCode</a>;</code></div></li><li><div class="item-name" id="reexport.InvalidDeriveTarget"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.InvalidDeriveTarget.html" title="struct hir::diagnostics::InvalidDeriveTarget">InvalidDeriveTarget</a>;</code></div></li><li><div class="item-name" id="reexport.MacroDefError"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MacroDefError.html" title="struct hir::diagnostics::MacroDefError">MacroDefError</a>;</code></div></li><li><div class="item-name" id="reexport.MacroError"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MacroError.html" title="struct hir::diagnostics::MacroError">MacroError</a>;</code></div></li><li><div class="item-name" id="reexport.MacroExpansionParseError"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MacroExpansionParseError.html" title="struct hir::diagnostics::MacroExpansionParseError">MacroExpansionParseError</a>;</code></div></li><li><div class="item-name" id="reexport.MalformedDerive"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MalformedDerive.html" title="struct hir::diagnostics::MalformedDerive">MalformedDerive</a>;</code></div></li><li><div class="item-name" id="reexport.MismatchedArgCount"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MismatchedArgCount.html" title="struct hir::diagnostics::MismatchedArgCount">MismatchedArgCount</a>;</code></div></li><li><div class="item-name" id="reexport.MissingFields"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MissingFields.html" title="struct hir::diagnostics::MissingFields">MissingFields</a>;</code></div></li><li><div class="item-name" id="reexport.MissingMatchArms"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MissingMatchArms.html" title="struct hir::diagnostics::MissingMatchArms">MissingMatchArms</a>;</code></div></li><li><div class="item-name" id="reexport.MissingUnsafe"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.MissingUnsafe.html" title="struct hir::diagnostics::MissingUnsafe">MissingUnsafe</a>;</code></div></li><li><div class="item-name" id="reexport.NeedMut"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.NeedMut.html" title="struct hir::diagnostics::NeedMut">NeedMut</a>;</code></div></li><li><div class="item-name" id="reexport.NoSuchField"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.NoSuchField.html" title="struct hir::diagnostics::NoSuchField">NoSuchField</a>;</code></div></li><li><div class="item-name" id="reexport.PrivateAssocItem"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.PrivateAssocItem.html" title="struct hir::diagnostics::PrivateAssocItem">PrivateAssocItem</a>;</code></div></li><li><div class="item-name" id="reexport.PrivateField"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.PrivateField.html" title="struct hir::diagnostics::PrivateField">PrivateField</a>;</code></div></li><li><div class="item-name" id="reexport.ReplaceFilterMapNextWithFindMap"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.ReplaceFilterMapNextWithFindMap.html" title="struct hir::diagnostics::ReplaceFilterMapNextWithFindMap">ReplaceFilterMapNextWithFindMap</a>;</code></div></li><li><div class="item-name" id="reexport.TypeMismatch"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.TypeMismatch.html" title="struct hir::diagnostics::TypeMismatch">TypeMismatch</a>;</code></div></li><li><div class="item-name" id="reexport.UndeclaredLabel"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UndeclaredLabel.html" title="struct hir::diagnostics::UndeclaredLabel">UndeclaredLabel</a>;</code></div></li><li><div class="item-name" id="reexport.UnimplementedBuiltinMacro"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnimplementedBuiltinMacro.html" title="struct hir::diagnostics::UnimplementedBuiltinMacro">UnimplementedBuiltinMacro</a>;</code></div></li><li><div class="item-name" id="reexport.UnreachableLabel"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnreachableLabel.html" title="struct hir::diagnostics::UnreachableLabel">UnreachableLabel</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedExternCrate"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedExternCrate.html" title="struct hir::diagnostics::UnresolvedExternCrate">UnresolvedExternCrate</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedField"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedField.html" title="struct hir::diagnostics::UnresolvedField">UnresolvedField</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedImport"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedImport.html" title="struct hir::diagnostics::UnresolvedImport">UnresolvedImport</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedMacroCall"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedMacroCall.html" title="struct hir::diagnostics::UnresolvedMacroCall">UnresolvedMacroCall</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedMethodCall"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedMethodCall.html" title="struct hir::diagnostics::UnresolvedMethodCall">UnresolvedMethodCall</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedModule"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedModule.html" title="struct hir::diagnostics::UnresolvedModule">UnresolvedModule</a>;</code></div></li><li><div class="item-name" id="reexport.UnresolvedProcMacro"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnresolvedProcMacro.html" title="struct hir::diagnostics::UnresolvedProcMacro">UnresolvedProcMacro</a>;</code></div></li><li><div class="item-name" id="reexport.UnusedMut"><code>pub use crate::diagnostics::<a class="struct" href="diagnostics/struct.UnusedMut.html" title="struct hir::diagnostics::UnusedMut">UnusedMut</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="db/index.html" title="mod hir::db">db</a></div><div class="desc docblock-short">Re-exports various subcrates databases so that the calling code can depend
only on <code>hir</code>. This breaks abstraction boundary a bit, it would be cool if
we didn’t do that.</div></li><li><div class="item-name"><a class="mod" href="diagnostics/index.html" title="mod hir::diagnostics">diagnostics</a></div><div class="desc docblock-short">Re-export diagnostics such that clients of <code>hir</code> don’t have to depend on
low-level crates.</div></li><li><div class="item-name"><a class="mod" href="import_map/index.html" title="mod hir::import_map">import_map</a></div><div class="desc docblock-short">A map of all publicly exported items in a crate.</div></li><li><div class="item-name"><a class="mod" href="known/index.html" title="mod hir::known">known</a></div></li><li><div class="item-name"><a class="mod" href="symbols/index.html" title="mod hir::symbols">symbols</a></div><div class="desc docblock-short">File symbol extraction.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Adjustment.html" title="struct hir::Adjustment">Adjustment</a></div></li><li><div class="item-name"><a class="struct" href="struct.Attr.html" title="struct hir::Attr">Attr</a></div></li><li><div class="item-name"><a class="struct" href="struct.AttributeTemplate.html" title="struct hir::AttributeTemplate">AttributeTemplate</a></div><div class="desc docblock-short">A template that the attribute input must match.
Only top-level shape (<code>#[attr]</code> vs <code>#[attr(...)]</code> vs <code>#[attr = ...]</code>) is considered now.</div></li><li><div class="item-name"><a class="struct" href="struct.Attrs.html" title="struct hir::Attrs">Attrs</a></div></li><li><div class="item-name"><a class="struct" href="struct.AttrsWithOwner.html" title="struct hir::AttrsWithOwner">AttrsWithOwner</a></div></li><li><div class="item-name"><a class="struct" href="struct.BuiltinAttr.html" title="struct hir::BuiltinAttr">BuiltinAttr</a></div></li><li><div class="item-name"><a class="struct" href="struct.BuiltinType.html" title="struct hir::BuiltinType">BuiltinType</a></div></li><li><div class="item-name"><a class="struct" href="struct.Callable.html" title="struct hir::Callable">Callable</a></div></li><li><div class="item-name"><a class="struct" href="struct.CfgOptions.html" title="struct hir::CfgOptions">CfgOptions</a></div><div class="desc docblock-short">Configuration options used for conditional compilation on items with <code>cfg</code> attributes.
We have two kind of options in different namespaces: atomic options like <code>unix</code>, and
key-value options like <code>target_arch=&quot;x86&quot;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Const.html" title="struct hir::Const">Const</a></div></li><li><div class="item-name"><a class="struct" href="struct.ConstParam.html" title="struct hir::ConstParam">ConstParam</a></div></li><li><div class="item-name"><a class="struct" href="struct.Crate.html" title="struct hir::Crate">Crate</a></div><div class="desc docblock-short">hir::Crate describes a single crate. It’s the main interface with which
a crate’s dependencies interact. Mostly, it should be just a proxy for the
root module.</div></li><li><div class="item-name"><a class="struct" href="struct.CrateDependency.html" title="struct hir::CrateDependency">CrateDependency</a></div></li><li><div class="item-name"><a class="struct" href="struct.DeriveHelper.html" title="struct hir::DeriveHelper">DeriveHelper</a></div></li><li><div class="item-name"><a class="struct" href="struct.Documentation.html" title="struct hir::Documentation">Documentation</a></div><div class="desc docblock-short">Holds documentation</div></li><li><div class="item-name"><a class="struct" href="struct.Enum.html" title="struct hir::Enum">Enum</a></div></li><li><div class="item-name"><a class="struct" href="struct.Field.html" title="struct hir::Field">Field</a></div></li><li><div class="item-name"><a class="struct" href="struct.Function.html" title="struct hir::Function">Function</a></div></li><li><div class="item-name"><a class="struct" href="struct.HirFileId.html" title="struct hir::HirFileId">HirFileId</a></div><div class="desc docblock-short">Input to the analyzer is a set of files, where each file is identified by
<code>FileId</code> and contains source code. However, another source of source code in
Rust are macros: each macro can be thought of as producing a “temporary
file”. To assign an id to such a file, we use the id of the macro call that
produced the file. So, a <code>HirFileId</code> is either a <code>FileId</code> (source code
written by user), or a <code>MacroCallId</code> (source code produced by macro).</div></li><li><div class="item-name"><a class="struct" href="struct.Impl.html" title="struct hir::Impl">Impl</a></div></li><li><div class="item-name"><a class="struct" href="struct.InFile.html" title="struct hir::InFile">InFile</a></div><div class="desc docblock-short"><code>InFile&lt;T&gt;</code> stores a value of <code>T</code> inside a particular file/syntax tree.</div></li><li><div class="item-name"><a class="struct" href="struct.IncoherentImpl.html" title="struct hir::IncoherentImpl">IncoherentImpl</a></div></li><li><div class="item-name"><a class="struct" href="struct.IncorrectCase.html" title="struct hir::IncorrectCase">IncorrectCase</a></div></li><li><div class="item-name"><a class="struct" href="struct.Label.html" title="struct hir::Label">Label</a></div></li><li><div class="item-name"><a class="struct" href="struct.LifetimeParam.html" title="struct hir::LifetimeParam">LifetimeParam</a></div></li><li><div class="item-name"><a class="struct" href="struct.Local.html" title="struct hir::Local">Local</a></div><div class="desc docblock-short">A single local definition.</div></li><li><div class="item-name"><a class="struct" href="struct.LocalSource.html" title="struct hir::LocalSource">LocalSource</a></div></li><li><div class="item-name"><a class="struct" href="struct.Macro.html" title="struct hir::Macro">Macro</a></div></li><li><div class="item-name"><a class="struct" href="struct.MacroFile.html" title="struct hir::MacroFile">MacroFile</a></div></li><li><div class="item-name"><a class="struct" href="struct.ModPath.html" title="struct hir::ModPath">ModPath</a></div></li><li><div class="item-name"><a class="struct" href="struct.Module.html" title="struct hir::Module">Module</a></div></li><li><div class="item-name"><a class="struct" href="struct.Name.html" title="struct hir::Name">Name</a></div><div class="desc docblock-short"><code>Name</code> is a wrapper around string, which is used in hir for both references
and declarations. In theory, names should also carry hygiene info, but we are
not there yet!</div></li><li><div class="item-name"><a class="struct" href="struct.OverloadedDeref.html" title="struct hir::OverloadedDeref">OverloadedDeref</a></div></li><li><div class="item-name"><a class="struct" href="struct.Param.html" title="struct hir::Param">Param</a></div></li><li><div class="item-name"><a class="struct" href="struct.SelfParam.html" title="struct hir::SelfParam">SelfParam</a></div></li><li><div class="item-name"><a class="struct" href="struct.Semantics.html" title="struct hir::Semantics">Semantics</a></div><div class="desc docblock-short">Primary API to get semantic information, like types, from syntax trees.</div></li><li><div class="item-name"><a class="struct" href="struct.SemanticsScope.html" title="struct hir::SemanticsScope">SemanticsScope</a></div><div class="desc docblock-short"><code>SemanticsScope</code> encapsulates the notion of a scope (the set of visible
names) at a particular program point.</div></li><li><div class="item-name"><a class="struct" href="struct.Static.html" title="struct hir::Static">Static</a></div></li><li><div class="item-name"><a class="struct" href="struct.Struct.html" title="struct hir::Struct">Struct</a></div></li><li><div class="item-name"><a class="struct" href="struct.ToolModule.html" title="struct hir::ToolModule">ToolModule</a></div></li><li><div class="item-name"><a class="struct" href="struct.Trait.html" title="struct hir::Trait">Trait</a></div></li><li><div class="item-name"><a class="struct" href="struct.TraitAlias.html" title="struct hir::TraitAlias">TraitAlias</a></div></li><li><div class="item-name"><a class="struct" href="struct.TraitRef.html" title="struct hir::TraitRef">TraitRef</a></div></li><li><div class="item-name"><a class="struct" href="struct.Type.html" title="struct hir::Type">Type</a></div></li><li><div class="item-name"><a class="struct" href="struct.TypeAlias.html" title="struct hir::TypeAlias">TypeAlias</a></div></li><li><div class="item-name"><a class="struct" href="struct.TypeInfo.html" title="struct hir::TypeInfo">TypeInfo</a></div></li><li><div class="item-name"><a class="struct" href="struct.TypeOrConstParam.html" title="struct hir::TypeOrConstParam">TypeOrConstParam</a></div></li><li><div class="item-name"><a class="struct" href="struct.TypeParam.html" title="struct hir::TypeParam">TypeParam</a></div></li><li><div class="item-name"><a class="struct" href="struct.Union.html" title="struct hir::Union">Union</a></div></li><li><div class="item-name"><a class="struct" href="struct.Variant.html" title="struct hir::Variant">Variant</a></div></li><li><div class="item-name"><a class="struct" href="struct.VisibleTraits.html" title="struct hir::VisibleTraits">VisibleTraits</a></div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Access.html" title="enum hir::Access">Access</a></div></li><li><div class="item-name"><a class="enum" href="enum.Adjust.html" title="enum hir::Adjust">Adjust</a></div></li><li><div class="item-name"><a class="enum" href="enum.Adt.html" title="enum hir::Adt">Adt</a></div><div class="desc docblock-short">A Data Type</div></li><li><div class="item-name"><a class="enum" href="enum.AssocItem.html" title="enum hir::AssocItem">AssocItem</a></div><div class="desc docblock-short">Invariant: <code>inner.as_assoc_item(db).is_some()</code>
We do not actively enforce this invariant.</div></li><li><div class="item-name"><a class="enum" href="enum.AssocItemContainer.html" title="enum hir::AssocItemContainer">AssocItemContainer</a></div></li><li><div class="item-name"><a class="enum" href="enum.AutoBorrow.html" title="enum hir::AutoBorrow">AutoBorrow</a></div></li><li><div class="item-name"><a class="enum" href="enum.BindingMode.html" title="enum hir::BindingMode">BindingMode</a></div></li><li><div class="item-name"><a class="enum" href="enum.CallableKind.html" title="enum hir::CallableKind">CallableKind</a></div></li><li><div class="item-name"><a class="enum" href="enum.CfgAtom.html" title="enum hir::CfgAtom">CfgAtom</a></div><div class="desc docblock-short">A simple configuration value passed in from the outside.</div></li><li><div class="item-name"><a class="enum" href="enum.CfgExpr.html" title="enum hir::CfgExpr">CfgExpr</a></div></li><li><div class="item-name"><a class="enum" href="enum.ClosureStyle.html" title="enum hir::ClosureStyle">ClosureStyle</a></div></li><li><div class="item-name"><a class="enum" href="enum.DefWithBody.html" title="enum hir::DefWithBody">DefWithBody</a></div><div class="desc docblock-short">The defs which have a body.</div></li><li><div class="item-name"><a class="enum" href="enum.FieldSource.html" title="enum hir::FieldSource">FieldSource</a></div></li><li><div class="item-name"><a class="enum" href="enum.GenericDef.html" title="enum hir::GenericDef">GenericDef</a></div></li><li><div class="item-name"><a class="enum" href="enum.GenericParam.html" title="enum hir::GenericParam">GenericParam</a></div></li><li><div class="item-name"><a class="enum" href="enum.HirDisplayError.html" title="enum hir::HirDisplayError">HirDisplayError</a></div></li><li><div class="item-name"><a class="enum" href="enum.ItemInNs.html" title="enum hir::ItemInNs">ItemInNs</a></div></li><li><div class="item-name"><a class="enum" href="enum.MacroKind.html" title="enum hir::MacroKind">MacroKind</a></div></li><li><div class="item-name"><a class="enum" href="enum.MirEvalError.html" title="enum hir::MirEvalError">MirEvalError</a></div></li><li><div class="item-name"><a class="enum" href="enum.ModuleDef.html" title="enum hir::ModuleDef">ModuleDef</a></div><div class="desc docblock-short">The defs which can be visible in the module.</div></li><li><div class="item-name"><a class="enum" href="enum.ModuleDefId.html" title="enum hir::ModuleDefId">ModuleDefId</a></div><div class="desc docblock-short">The defs which can be visible in the module.</div></li><li><div class="item-name"><a class="enum" href="enum.ModuleSource.html" title="enum hir::ModuleSource">ModuleSource</a></div></li><li><div class="item-name"><a class="enum" href="enum.Mutability.html" title="enum hir::Mutability">Mutability</a></div></li><li><div class="item-name"><a class="enum" href="enum.Namespace.html" title="enum hir::Namespace">Namespace</a></div></li><li><div class="item-name"><a class="enum" href="enum.Origin.html" title="enum hir::Origin">Origin</a></div></li><li><div class="item-name"><a class="enum" href="enum.PathKind.html" title="enum hir::PathKind">PathKind</a></div></li><li><div class="item-name"><a class="enum" href="enum.PathResolution.html" title="enum hir::PathResolution">PathResolution</a></div></li><li><div class="item-name"><a class="enum" href="enum.PointerCast.html" title="enum hir::PointerCast">PointerCast</a></div></li><li><div class="item-name"><a class="enum" href="enum.PrefixKind.html" title="enum hir::PrefixKind">PrefixKind</a></div></li><li><div class="item-name"><a class="enum" href="enum.Safety.html" title="enum hir::Safety">Safety</a></div><div class="desc docblock-short">Whether a function is safe or not.</div></li><li><div class="item-name"><a class="enum" href="enum.ScopeDef.html" title="enum hir::ScopeDef">ScopeDef</a></div><div class="desc docblock-short">For IDE only</div></li><li><div class="item-name"><a class="enum" href="enum.StructKind.html" title="enum hir::StructKind">StructKind</a></div></li><li><div class="item-name"><a class="enum" href="enum.TypeRef.html" title="enum hir::TypeRef">TypeRef</a></div><div class="desc docblock-short">Compare ty::Ty</div></li><li><div class="item-name"><a class="enum" href="enum.VariantDef.html" title="enum hir::VariantDef">VariantDef</a></div></li><li><div class="item-name"><a class="enum" href="enum.Visibility.html" title="enum hir::Visibility">Visibility</a></div><div class="desc docblock-short">Visibility of an item, with the path resolved.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AsAssocItem.html" title="trait hir::AsAssocItem">AsAssocItem</a></div></li><li><div class="item-name"><a class="trait" href="trait.HasAttrs.html" title="trait hir::HasAttrs">HasAttrs</a></div></li><li><div class="item-name"><a class="trait" href="trait.HasCrate.html" title="trait hir::HasCrate">HasCrate</a></div><div class="desc docblock-short">Trait for obtaining the defining crate of an item.</div></li><li><div class="item-name"><a class="trait" href="trait.HasSource.html" title="trait hir::HasSource">HasSource</a></div></li><li><div class="item-name"><a class="trait" href="trait.HasVisibility.html" title="trait hir::HasVisibility">HasVisibility</a></div></li><li><div class="item-name"><a class="trait" href="trait.HirDisplay.html" title="trait hir::HirDisplay">HirDisplay</a></div></li><li><div class="item-name"><a class="trait" href="trait.HirWrite.html" title="trait hir::HirWrite">HirWrite</a></div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ExpandResult.html" title="type hir::ExpandResult">ExpandResult</a></div></li></ul></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="hir" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>